<!doctype html>
<html>
<head>
  <title>Check performance of Indexed</title>
  <style type="text/css">
    #result {
      padding: 50px;
      font: 20px/1.5 "Helvetica Neue", Helvetica, Arial, sans-serif;
    }
  </style>
  <script src="build/build.js"></script>
  <script src="node_modules/async/lib/async.js"></script>
  <script src="node_modules/underscore/underscore.js"></script>
</head>
<body>
  <div id="result"></div>

  <script type="text/javascript">
    var Indexed  = require('indexed');

    Indexed.drop('notepad', function(err) {
      var notes    = new Indexed('notepad:notes');
      var tags     = new Indexed('notepad:tags');
      var notepads = new Indexed('notepad:notepads');

      function fibonacci(n) {
        return (n <= 0) ? 0 : (n === 1) ? 1 : fibonacci(n-1) + fibonacci(n-2);
      }

      function sum(arr) {
        return _.reduce(arr, function(memo, num){ return memo + num; }, 0);
      }

      function append(text) {
        var block = document.createElement('p')
        block.innerHTML = text
        document.getElementById('result').appendChild(block);
      }

      function recap(array, name) {
        var time  = sum(array);
        var length = array.length;

        append(name
          + ' = count: '
          + length
          + '; time: '
          + time
          + 'ms; mean: '
          + (time / length).toFixed(2)
          + 'ms;');
      }

      /**
       * Random get/put/del
       * 2000/2000/2000 times
       *
       * Use fiboncacci to emulate massice put and than massive del
       * Every iteration read 100 random items
       */

      var putId = 0, delId = 0;
      var createIndex = 15, deleteIndex = 0;
      var putTimes = [], getTimes = [], delTimes = [];

      append('Calculating "random get/put/del"');

      async.eachSeries(_.range(createIndex, 0, -1), function(i, nextIter) {
        async.series([
          function(cb) {
            async.eachSeries(_.range(1, fibonacci(createIndex) + 1), function(item, next) {
              var date  = new Date;
              var start = +date;
              var attrs = { note: 'note ' + putId, createdAt: date, updatedAt: date };
              putId += 1;
              notes.put(putId, attrs, function(err) {
                putTimes.push(+(new Date) - start);
                next(err);
              });
            }, cb);
          },
          function(cb) {
            async.eachSeries(_.range(1, 101), function(item, next) {
              var getId = _.random(delId, putId);
              var start = +(new Date);
              notes.get(getId, function(err, note) {
                getTimes.push(+(new Date) - start);
                next(err);
              });
            }, cb);
          },
          function(cb) {
            async.eachSeries(_.range(1, fibonacci(deleteIndex) + 1), function(item, next) {
              var start = +(new Date);
              delId += 1;
              notes.del(delId, function(err) {
                delTimes.push(+(new Date) - start);
                next(err);
              });
            }, cb);
          }
        ], nextIter);

        createIndex -= 1;
        deleteIndex += 1;
      }, function(err) {
        if (err) throw new Error(err);

        recap(putTimes, 'Put');
        recap(getTimes, 'Get');
        recap(delTimes, 'Del');
      });
    });
  </script>
</body>
</html>